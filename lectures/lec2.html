<!DOCTYPE html>
<html>
<head>
<title>lecture2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>
<h1 id="lecture-2---computational-complexity--parsing-and-string-manipulation">Lecture 2 - Computational Complexity / Parsing and String Manipulation</h1>
<ul>
<li>Additional resources can be found <a href="https://billlidc.github.io/Data-Structures/lectures/lecture1.html">here</a>.</li>
</ul>
<hr>
<h2 id="computational-complexity">Computational Complexity</h2>
<ul>
<li>Describes the &quot;difficulty&quot; of a problem</li>
<li>States resource usage as a function of the given problem's &quot;size&quot;
<ul>
<li>Usually time or memory</li>
</ul>
</li>
</ul>
<h3 id="big-o-notation">Big-O Notation</h3>
<ul>
<li>
<p>Describes the asymptotic behavior of a function</p>
</li>
<li>
<p>can be arbitrarily &quot;loose&quot;</p>
<ul>
<li>If $f(x)$ is $O(n^2)$, it is also $O(n^3)$, $O(n^4)$, $O(2^n)$, etc.</li>
</ul>
</li>
<li>
<p>Definition
$$
f(n) = O(g(n)) \text{ if there exist constants } c &gt; 0 \text{ and } n_0 &gt; 0 \text{ such that } 0 \leq f(n) \leq c \cdot g(n) \text{ for all } n \geq n_0
$$</p>
</li>
</ul>
<div style="border: 1px solid black; padding: 10px; margin: 10px;">
  <p>
<ul>
<li>$O(1)$: <strong>Constant</strong> time
<ul>
<li>The algorithm does NOT depend on the input size.</li>
</ul>
</li>
<li>$O(\log n)$: <strong>Logarithmic</strong> time
<ul>
<li>The algorithm gets slightly slower as $n$ grows.</li>
</ul>
</li>
<li>$O(n)$: <strong>Linear</strong> time
<ul>
<li>The runtime grows as much as $n$ grows (When $n$ doubles, runtime doubles).</li>
</ul>
</li>
<li>$O(n \cdot \log n)$: <strong>Linearithmic</strong> time
<ul>
<li>Usually the result of performing $O(\log n)$ operation $n$ times or performing $O(n)$ operation $log n$ times.</li>
</ul>
</li>
<li>$O(n^c)$: <strong>Polynomial</strong> time
<ul>
<li>$O(n^2)$: <strong>Quadratic</strong> time</li>
<li>$O(n^3)$ <strong>Cubic</strong> time</li>
</ul>
</li>
<li>$O(2^n)$: <strong>Exponential</strong> time</li>
<li>$O(n!)$: <strong>Factorial</strong> time</li>
</ul>
  </p>
</div>
<h3 id="when-is-on%C2%B2-better-than-on">When is <code>O(nÂ²)</code> Better than <code>O(n)</code>?</h3>
<ul>
<li><code>4nÂ² &lt; 1000n</code> whenever <code>n &lt; 250</code>.
<ul>
<li><strong>When <code>n</code> is known to be small</strong> and the <code>O(nÂ²)</code> algorithm has a lower constant factor than the <code>O(n)</code> algorithm.</li>
<li>In such cases, even though <code>O(nÂ²)</code> grows faster with larger <code>n</code>, the actual performance for small <code>n</code> can be better than the <code>O(n)</code> algorithm due to a smaller constant factor.</li>
</ul>
</li>
</ul>
<h3 id="big-o-examples">Big-O Examples</h3>
<ul>
<li>
<p>Checking whether an item is present in a linked list: <code>O(n)</code></p>
<ul>
<li>Scan through the entire list until the item is found (on average <code>n/2</code> checks)</li>
</ul>
</li>
<li>
<p>Checking whether an item is present in an unordered binary tree: <code>O(n)</code></p>
</li>
<li>
<p>Checking whether an item is present in a binary search tree: <code>O(H)</code></p>
<ul>
<li>If the tree is degenerate (like a linked list), <code>H = n</code></li>
<li>If the tree is balanced, <code>H = log n</code></li>
</ul>
</li>
</ul>
<h3 id="big-o-sanity-checking">Big-O Sanity-Checking</h3>
<ul>
<li>Determine <strong>the least conceivable</strong> work or space needed to accomplish the task
<ul>
<li>Can <strong>NOT</strong> be <code>O(log n)</code> or faster than <code>O(n)</code> to examine every single item of input</li>
<li>Can <strong>NOT</strong> be faster than <code>O(nÂ²)</code> for quadratic working memory</li>
</ul>
</li>
</ul>
<hr>
<h2 id="amortized-time">Amortized Time</h2>
<ul>
<li>Additional resources can be found <a href="https://billlidc.github.io/Data-Structures/lectures/lecture4.html">here</a>.</li>
</ul>
<hr>
<h2 id="parsing-and-string-manipulation">Parsing and String Manipulation</h2>
<h3 id="java-string-functions-access">Java String Functions: Access</h3>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char charAt(int index)</code></td>
<td>Return the character at the given position.</td>
</tr>
<tr>
<td><code>int codePointAt(int index)</code></td>
<td>Return the Unicode code point at the specified position.</td>
</tr>
<tr>
<td><code>int length()</code></td>
<td>Return the length of the string.</td>
</tr>
<tr>
<td><code>int codePointCount(int b, int e)</code></td>
<td>Return the number of Unicode code points in the range from index <code>b</code> to <code>e</code>.</td>
</tr>
</tbody>
</table>
<h3 id="java-string-functions-testing">Java String Functions: Testing</h3>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.contains(CharSequence cs)</code></td>
<td>Return <code>True</code> if <code>cs</code> is a subsequence of <code>s</code>.</td>
</tr>
<tr>
<td><code>s.startsWith(String pre)</code></td>
<td>Return <code>True</code> if <code>s</code> starts with the prefix <code>pre</code>.</td>
</tr>
<tr>
<td><code>s.endsWith(String suf)</code></td>
<td>Return <code>True</code> if <code>s</code> ends with the suffix <code>suf</code>.</td>
</tr>
<tr>
<td><code>int s1.indexOf(int ch)</code></td>
<td>Return the index of the first occurrence of <code>ch</code>.</td>
</tr>
<tr>
<td><code>int s1.indexOf(String s2)</code></td>
<td>Return the index of the first occurrence of the string <code>s2</code>.</td>
</tr>
<tr>
<td><code>int s1.lastIndexOf(ch/s2)</code></td>
<td>Return the index of the last occurrence of <code>ch</code> or <code>s2</code>.</td>
</tr>
</tbody>
</table>
<h3 id="java-string-functions-modification">Java String Functions: Modification</h3>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.replace(c1, c2)</code></td>
<td>Replace all occurrences of <code>c1</code> with <code>c2</code>.</td>
</tr>
<tr>
<td><code>s.toLowerCase()</code></td>
<td>Convert all characters in <code>s</code> to lowercase.</td>
</tr>
<tr>
<td><code>s.toUpperCase()</code></td>
<td>Convert all characters in <code>s</code> to uppercase.</td>
</tr>
</tbody>
</table>
<h3 id="java-string-functions-assemblydisassembly">Java String Functions: Assembly/Disassembly</h3>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s1.concat(s2)</code><br><code>s1 += s2</code></td>
<td>Append <code>s2</code> to the end of <code>s1</code>.</td>
</tr>
<tr>
<td><code>String.valueOf(char[] arr)</code></td>
<td>Return a new string containing the characters in <code>arr</code>.</td>
</tr>
<tr>
<td><code>s.substring(int b, int e)</code></td>
<td>Return a new string containing the substring from index <code>b</code> to <code>e</code>.</td>
</tr>
<tr>
<td><code>s.trim()</code></td>
<td>Return <code>s</code> without leading and trailing whitespace.</td>
</tr>
<tr>
<td><code>String[] s.split(String regex)</code></td>
<td>Split <code>s</code> around occurrences of the regex pattern.</td>
</tr>
</tbody>
</table>
<h3 id="java-string-functions-comparison">Java String Functions: Comparison</h3>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string1 == string2</code></td>
<td>Returns <code>True</code> if <code>string1</code> and <code>string2</code> reference the same instance.</td>
</tr>
<tr>
<td><code>string1.equals(string2)</code></td>
<td>Returns <code>True</code> if <code>string1</code> and <code>string2</code> have the same content.</td>
</tr>
<tr>
<td><code>string1.compareTo(string2)</code></td>
<td>Returns <code>0</code> if equal, <code>-1</code> if <code>string1</code> is lexically before <code>string2</code>, <code>+1</code> if after.</td>
</tr>
<tr>
<td><code>string1.compareToIgnoreCase(string2)</code></td>
<td>Returns <code>0</code> if <code>string1</code> and <code>string2</code> have the same content, ignoring case.</td>
</tr>
<tr>
<td><code>s.matches(String regex)</code></td>
<td>Returns <code>True</code> if <code>s</code> matches the regular expression <code>regex</code>.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="regular-expressions">Regular Expressions</h2>
<h3 id="building-blocks-of-regular-expressions">Building Blocks of Regular Expressions</h3>
<ol>
<li>
<p><strong>Character Literal</strong>: Matches a specific character</p>
<ul>
<li><code>&quot;a&quot;</code>: Matches the letter <code>a</code></li>
</ul>
</li>
<li>
<p><strong>Character Wildcard (<code>.</code>)</strong>: Matches any single character</p>
<ul>
<li><code>&quot;.&quot;</code>: Matches any character</li>
</ul>
</li>
<li>
<p><strong>Character Set (<code>[...]</code>)</strong>: Matches any one of the characters within the brackets</p>
<ul>
<li><code>&quot;[aeiou]&quot;</code>: Matches any vowel</li>
<li>(<code>[^...]</code>): Matches anything not in the set</li>
<li><code>[^0-9]</code>: Matches any character that is not a digit</li>
</ul>
</li>
<li>
<p><strong>Repetition</strong>:</p>
<ul>
<li><code>X?</code>: Matches <code>0</code> or <code>1</code> occurrence of <code>X</code> (X is optional)</li>
<li><code>X*</code>: Matches <code>0</code> or more occurrences of <code>X</code></li>
<li><code>X+</code>: Matches <code>1</code> or more occurrences of <code>X</code></li>
</ul>
</li>
<li>
<p><strong>Concatenation</strong>: Combines multiple expressions</p>
<ul>
<li><code>XY</code>: Matches X followed by Y</li>
</ul>
</li>
<li>
<p><strong>Alternation (<code>|</code>)</strong>: Matches either the expression before or after <code>|</code></p>
<ul>
<li><code>X|Y</code>: Matches <code>X</code> or <code>Y</code></li>
</ul>
</li>
</ol>
<h3 id="anchors">Anchors</h3>
<ul>
<li>
<p><strong><code>^</code> (Caret)</strong>: Matches the start of the string</p>
<ul>
<li><code>^abc</code>: Matches <code>abc</code> only at the start</li>
</ul>
</li>
<li>
<p><strong><code>$</code> (Dollar)</strong>: Matches the end of the string</p>
<ul>
<li><code>abc$</code>: Matches <code>abc</code> only at the end</li>
</ul>
</li>
</ul>
<h3 id="extended-regular-expressions">Extended Regular Expressions</h3>
<ol>
<li>
<p><strong>Finer Control Over Repetition</strong>:</p>
<ul>
<li><code>X{m,n}</code>: Matches at least <code>m</code> and at most <code>n</code> occurrences of <code>X</code></li>
<li><code>X{m,}</code>: Matches at least <code>m</code> consecutive occurrences of <code>X</code></li>
<li><code>X{,n}</code>: Matches at most <code>n</code> consecutive occurrences of <code>X</code></li>
</ul>
</li>
<li>
<p><strong>Grouping and Capture</strong>:</p>
<ul>
<li><code>(X...)</code>: Groups expressions to be treated as a single unit</li>
<li><code>...(X)...</code>: Captures matched text for later reference</li>
</ul>
</li>
</ol>
<h3 id="special-use-of-backslash">Special Use of Backslash (<code>\</code>)</h3>
<ol>
<li>
<p><strong>Escape Special Characters</strong>: Makes a special character literal</p>
<ul>
<li><code>\[ </code>: Matches <code>[</code></li>
</ul>
</li>
<li>
<p><strong>Referencing Matches</strong>:</p>
<ul>
<li><code>\1</code>, <code>\2</code>, etc., refer to previously captured groups</li>
</ul>
</li>
<li>
<p><strong>Shortcut Expressions</strong>:</p>
<ul>
<li><code>\s</code>: Matches any whitespace</li>
<li><code>\d</code>: Matches any digit (<code>[0-9]</code>)</li>
<li><code>\D</code>: Matches any non-digit</li>
<li><code>\w</code>: Matches any word character (<code>[a-zA-Z0-9_]</code>)</li>
</ul>
</li>
<li>
<p><strong>Literal Backslash</strong>:</p>
<ul>
<li>Use <code>\\</code> to match a single backslash</li>
</ul>
</li>
</ol>
<h3 id="regular-expression-examples">Regular Expression Examples</h3>
<table>
<thead>
<tr>
<th><strong>Expression</strong></th>
<th><strong>Matches</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abc</code></td>
<td><code>abc</code> only</td>
</tr>
<tr>
<td><code>ab*c</code></td>
<td><code>ac</code>, <code>abc</code>, <code>abbc</code>, <code>abbbc</code>, <code>abbbbc</code>, etc.</td>
</tr>
<tr>
<td><code>.\.</code></td>
<td>Any character followed by a period</td>
</tr>
<tr>
<td><code>(a\|bc)d</code></td>
<td><code>acd</code> and <code>bcd</code></td>
</tr>
<tr>
<td><code>(a\|(bc))d</code></td>
<td><code>ad</code> and <code>bcd</code></td>
</tr>
<tr>
<td><code>x[aeiou]?z</code></td>
<td><code>xz</code>, <code>xaz</code>, <code>xez</code>, <code>xiz</code>, <code>xoz</code>, and <code>xuz</code></td>
</tr>
<tr>
<td><code>b{3,4}</code></td>
<td><code>bbb</code> and <code>bbbb</code></td>
</tr>
<tr>
<td><code>^a</code></td>
<td><code>a</code> only â multiple leading carets all anchor to start</td>
</tr>
<tr>
<td><code>^\^a</code></td>
<td><code>^a</code></td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td><code>A</code>, <code>B</code>, ..., <code>Z</code></td>
</tr>
<tr>
<td><code>[^0-9]</code></td>
<td>Any character except a digit</td>
</tr>
<tr>
<td><code>\d{3}-\d{2}-\d{4}</code></td>
<td><code>123-45-6789</code></td>
</tr>
<tr>
<td><code>\bword\b</code></td>
<td><code>word</code></td>
</tr>
<tr>
<td><code>X+</code></td>
<td><code>X</code>, <code>XX</code>, <code>XXX</code>, etc.</td>
</tr>
<tr>
<td><code>^abc$</code></td>
<td><code>abc</code></td>
</tr>
<tr>
<td><code>foo\|bar</code></td>
<td><code>foo</code> or <code>bar</code></td>
</tr>
<tr>
<td><code>a(bc)*d</code></td>
<td><code>ad</code>, <code>abcd</code>, <code>abcbcd</code>, etc.</td>
</tr>
<tr>
<td><code>\w+@\w+\.\w+</code></td>
<td><code>example@domain.com</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>A single whitespace character</td>
</tr>
<tr>
<td><code>(\d{3})</code></td>
<td>Captures three digits (e.g., <code>123</code>)</td>
</tr>
</tbody>
</table>
<h2 id="regex-functions-in-java">Regex Functions in Java</h2>
<ul>
<li>
<p><code>String.split</code></p>
<ul>
<li><code>String.split</code> is a convenience function that internally uses <code>Pattern.compile(re).split(str)</code>.<pre class="hljs"><code><div>String[] parts = <span class="hljs-string">"a,b,c"</span>.split(<span class="hljs-string">","</span>);
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>Efficient Re-use of Regex</p>
<ul>
<li>More efficient to compile once and reuse the <code>Pattern</code> object.<pre class="hljs"><code><div>Pattern p = Pattern.compile(regex);
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>Processing Multiple Matches</p>
<ul>
<li>
<p>Create a <code>Matcher</code> object to find multiple matches within a string.</p>
<pre class="hljs"><code><div>Pattern p = Pattern.compile(regex);
Matcher m = p.matcher(string);
</div></code></pre>
<ul>
<li><code>m.matches()</code>:
<ul>
<li>Equivalent to <code>string.matches(regex)</code>, checks if the <strong>entire</strong> string matches the pattern.</li>
</ul>
</li>
<li><code>m.find()</code>:
<ul>
<li>Looks for the next match in the string, returns <code>true</code> if found.</li>
</ul>
</li>
<li><code>m.group()</code>:
<ul>
<li>Returns the string that was matched by the most recent <code>find()</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Usage Example</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.regex.Matcher;
<span class="hljs-keyword">import</span> java.util.regex.Pattern;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegexTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// Define the regex pattern</span>
        String regex = <span class="hljs-string">"\\bword\\b"</span>; <span class="hljs-comment">// "\\b" represents word boundary</span>
        
        <span class="hljs-comment">// Compile the pattern</span>
        Pattern pattern = Pattern.compile(regex);
        
        <span class="hljs-comment">// Input string to match against</span>
        String input = <span class="hljs-string">"This is a word in a sentence. Another word appears here."</span>;

        <span class="hljs-comment">// Create a Matcher object</span>
        Matcher matcher = pattern.matcher(input);
        
        <span class="hljs-comment">// Check if the entire string matches the pattern</span>
        <span class="hljs-keyword">if</span> (matcher.matches()) {
            System.out.println(<span class="hljs-string">"The entire string matches the pattern."</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"The entire string does not match the pattern."</span>);
        }

        <span class="hljs-comment">// Find and print all occurrences of the pattern</span>
        <span class="hljs-keyword">while</span> (matcher.find()) {
            System.out.println(<span class="hljs-string">"Found a match: "</span> + matcher.group() + <span class="hljs-string">" at position "</span> + matcher.start());
        }
    }
}

<span class="hljs-comment">/*
Outputs:
Found a match: word at position 10
Found a match: word at position 38
*/</span>
</div></code></pre>
</li>
</ul>
<hr>
<p><a href="../index.html">Back to Home</a>
<a href="./lecture3.html">Next Lecture</a></p>

</body>
</html>
